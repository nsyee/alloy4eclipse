grammar fr.univartois.cril.alloyplugin.Basics with org.eclipse.xtext.common.Terminals
hidden(WS, ML_COMMENT, SL_COMMENT)
generate basics "http://www.univartois.fr/cril/alloyplugin/Basics"

Specification	:
	module=Module? open+=Open* paragraph+=Paragraph* ;
	
Module	:
	mod="module" name=Name ("[" "exactly"? suite=Name ("," "exactly"? INT)* "]")?;
	
Open	:
	"private"? open="open" name=Name ("[" ref=Ref ("," ref2+=Ref)* "]")? ("as" name2=Name)?;
	
Paragraph	:
	FactDecl	|
	AssertDecl	|
	FunDecl		|
	PredDecl	|
	RunDecl		|
	CheckDecl	|
	EnumDecl	|
	SigDecl		;
	
FactDecl	:
	fact="fact" name=Name? b=BlockBis;

AssertDecl	:
	assert="assert" name=Name? b=BlockBis;
	
FunDecl	:
	"private"? fun="fun" (ref=Ref ".")? name=Name	( "[" (decl+=Decl ",")* "]" | "(" (decl2+=Decl ",")* )? ":" expr=Expression b=BlockBis	;
	
PredDecl	:
	"private"? pred="pred" (ref=Ref ".")? name=Name	( "[" (decl+=Decl ",")* "]" | "(" (decl2+=Decl ",")* )?  b=BlockBis	;

RunDecl	:
	(name=Name ":")? run="run" (name2=[Name]| b=BlockBis ) scope=Scope;
	
CheckDecl	:
	(name=Name ":")? check="check" (name2=[Name]| b=BlockBis ) scope=Scope;
	
Scope	:
	("for" INT (("but")? typescope=Typescope ("," typescope=Typescope)*)?)? 	("expect" ("0"|"1")? )?	;										

Typescope	:
	"exactly"? INT (n=[Name]|("int"|"seq"))	;
	
	
EnumDecl	:
	enumeration="enum" name=Name "{" name2=Name ("," name3+=Name)* "}";
	
SigDecl	:
	sigQual=SigQual* "sig" name=Name ("," name2+=Name)* (sigExt=SigExt)? "{" (decl=Decl ("," decl2+=Decl)* )? "}" ;/*(b=BlockBis)?*/
	
enum SigQual	:
	ABSTRACT="abstract"	|
	LONE="lone"			|
	ONE="one"			|
	SOME="some"			|
	PRIVATE="private"	;
	
SigExt	:
	"extends" ref=Ref				|  
	"in" ref=Ref ("+" ref2+=Ref)*	;
	
Expression :
	
	(term=TerminalExpr) 	(
						"[" exprT=Expression* "]"													|
						op=("+"|"&"|"."|"-"|"||"|"or"|"&&"|"and"|"<=>"|"iff"|"=>"|"implies"|"++"|"<:"|":>"|"<<"	|">>"|">>>") right=Expression 	|
						("!"|"not")? op=("="|"in"|"<"|">"|"=<"|">=") right=Expression	|													//	|
						arrowOp=ArrowOp right=Expression																						
						//("=>"|"implies") then=Expression ("else" else=Expression)?        
						)?;
						
TerminalExpr returns Expression:
	//name=Name												|
	let="let" lets=LetDecls blockOrBarBis=BlockOrBarBis		|
	("all"|"sum") A											|
	("!"|"not"|"set"|"seq"|"#"|"~"|"*"|"^") TerminalExpr	|
   	("no"|"some"|"lone"|"one") (a=A| t=TerminalExpr)							|
    INT																			|
   	Integer																		|
	"none"																		|
	"iden"																		|
	"univ"																		|
	"Int"																		|
	"seq/Int"																	|
	"(" exprT=Expression ")"													|
	"@"? n=[Name]																|
	"{" (Block | (decl=Decl ",")+ blockOrBar=BlockOrBar "}")					;
	
A	:
	Decls b=BlockOrBarBis;

Decls	:
	decl=Decl2 ("," decl=Decl)*;
	
Decl	:
	("private")? ("disj")? Name ("," suite=Name)*    d=":" ("disj")? exprDecl=Expression	;
	
Decl2	:
	("private")? ("disj")? Name d=":" ("disj")? exprDecl=Expression	;
LetDecls:
	LetDecl ("," letDecl=LetDecl)*;
	
LetDecl	:
	Name "=" exprLet=Expression	;

ArrowOp	:
	("some" | "one" | "lone" | "set" )? s="->";
	
Block	:
	expr+=Expression* "}";

BlockBis	:
	"{" Block	;
	
BlockOrBar	:
	BlockBis					|
	"|" Expression	;
	
BlockOrBarBis	:
	BlockBis					|
	"|" TerminalExpr	;
	
Name :
	//{Name} ("this" | ID)? ("/" ID)*;
	//name=("this" | ID) ("/" ID)*;
	name=NameBis;
	
NameModule	:
	name=("this" | ID) ("/" ID)*;
	
Ref	:
	name=[Name]	|
	"univ"		|
	"Int"		|
	"seq/Int"	;
	
terminal Integer	:
	"-" INT;
	
terminal NameBis:
	ID ("/" ID)*;
	
/*	
Private	:
	priv="private"	;
	
	/*
Instruction	:
	M	| U;
	
M	:
	Expression ("=>" then=M "else" else=M)?;
	
U	:
	Expression "=>" then=Instruction	|
	Expression ("=>" then=M "else" else=U;*/