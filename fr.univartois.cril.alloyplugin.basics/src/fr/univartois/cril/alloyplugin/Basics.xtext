grammar fr.univartois.cril.alloyplugin.Basics with org.eclipse.xtext.common.Terminals 
hidden (WS, ML_COMMENT, SL_COMMENT)
generate basics "http://www.univartois.fr/cril/alloyplugin/Basics"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/*
	specification ::= [module] open* paragraph*
*/
Specification  :
  module=Module? open+=Open* paragraph+=Paragraph*; 

/*
	module ::= "module" name  [ "["  ["exactly"] name  ("," ["exactly"] num)*    "]" ]
*/
Module:
  "module" moduleName=Name ("[" "exactly"? suite=Name (Comma "exactly"? INT)* "]")?; 
  
/*
	open ::= ["private"]  "open"  name  [ "[" ref,+ "]" ]  [ "as" name ]
*/
Open:
  Private? "open" name=Name ("[" ref=Ref (Comma ref2+=Ref)* "]")? ("as" name2=Name)?; 
  
/*
	paragraph ::= factDecl | assertDecl | funDecl | cmdDecl | enumDecl | sigDecl
*/
Paragraph:
  FactDecl		|
  AssertDecl	|
  FunDecl		|
  PredDecl		|
  RunDecl		|
  CheckDecl		|
  EnumDecl		|
  SigDecl	; 

/*
	factDecl ::= "fact" [name] block
*/
FactDecl returns Fact:
  "fact" factName=TypeName? b=BlockBis; 

/*
	assertDecl ::= "assert" [name] block
*/
AssertDecl returns Assertion:
  "assert" assertName=AssertionName? b=BlockBis; 
  
/*
	funDecl ::= ["private"] "fun" [ref "."] name "(" decl,* ")" ":" expr block
	funDecl ::= ["private"] "fun" [ref "."] name "[" decl,* "]" ":" expr block
	funDecl ::= ["private"] "fun" [ref "."] name                ":" expr block
*/
FunDecl returns Function:
  Private? "fun" (ref=Ref Dote)? funName=TypeName ("[" (decl=Decl (Comma decl2+=Decl)*)? "]"|
  "(" (decl=Decl (Comma decl2+=Decl)*)? ")") Colon expr=Expression b=BlockBis; 
  
/*
	funDecl ::= ["private"] "pred" [ref "."] name "(" decl,* ")" block
	funDecl ::= ["private"] "pred" [ref "."] name "[" decl,* "]" block
	funDecl ::= ["private"] "pred" [ref "."] name                block
*/
PredDecl returns Predicate:
  Private? pred="pred" (ref=Ref Dote)? predName=PredicateName ("[" (decl=Decl (Comma decl2+=Decl)
  *)? "]"|"(" (decl=Decl (Comma decl2+=Decl)*)? ")")? b=BlockBis; 
  
/*
	cmdDecl ::= [name ":"] ["run"|"check"] [name|block] scope //JUST RUN
*/
RunDecl returns RunCommand:
  (runName=Alias ":")? run="run" (name2=[PredicateName]|b=BlockBis) scope=Scope; 
  
/*
	cmdDecl ::= [name ":"] ["run"|"check"] [name|block] scope //JUST CHECK
*/
CheckDecl returns CheckCommand:
  (checkName=Alias ":")? check="check" (name2=[AssertionName]|b=BlockBis) scope=Scope; 
  
/*
	scope ::= "for" number                   ["expect" [0|1]]
	scope ::= "for" number "but" typescope,+ ["expect" [0|1]]
	scope ::= "for"              typescope,+ ["expect" [0|1]]
	scope ::=                                ["expect" [0|1]]	
*/
Scope:
  ("for" (INT ("but" typescope=Typescope (Comma typescope=Typescope)*)?|typescope=Typescope (Comma typescope=Typescope)*)?)? ("expect" ("0"|"1"))?; 
  
/*
	typescope ::= ["exactly"] number [name|"int"|"seq"]
*/
Typescope:
  "exactly"? INT (n=[TypeName]|("int"|"seq")); 
  
/*
	enumDecl ::= "enum" name "{" name  ("," name)*  "}"
*/
EnumDecl:
  "enum" enumName=TypeName LeftCurlyBracket name2=TypeName (Comma name3+=TypeName)* RightCurlyBracket; 
  
/*
	sigDecl ::= sigQual* "sig" name,+ [sigExt] "{" decl,* "}" [block]
*/
SigDecl returns Signature:
  SigQual? "sig" sigName+=TypeName (Comma sigName+=TypeName)* (sigExt=SigExt)? LeftCurlyBracket (decl+=Decl ("," decl+=Decl)*)? RightCurlyBracket (b=BlockBis)?; 
  
/*
	sigQual ::= "abstract" | "lone" | "one" | "some" | "private"	
*/
SigQual:
  sigq=( "abstract" | "lone" | "one" | "some" | "private" ) ("abstract"|"lone"|"one"|"some"|"private")*; 
  
/*
	sigExt ::= "extends" ref
	sigExt ::= "in" ref ["+" ref]*
*/
SigExt:
  "extends" ref=Ref|"in" ref=Ref ("+" ref2+=Ref)*; /*
	expr ::= "let" letDecl,+ blockOrBar						1./	
       | quant decl,+    blockOrBar							2./
       | unOp expr											3./
       | expr binOp   expr									4./
       | expr arrowOp expr									5./
       | expr ["!"|"not"]? compareOp expr					6./
       | expr ["=>"|"implies"] expr "else" expr //PROBLEM	7./
       | expr "[" expr,* "]"								8./
       |     number											9./
       | "-" number											10./
       | "none"												11./
       | "iden"												12./
       | "univ"												13./
       | "Int"												14./
       | "seq/Int"											15./
       | "(" expr ")"										16./
       | ["@"] Name											17./
       | block												18./
       | "{" decl,+ blockOrBar "}"							19./
	
*/
Expression:
  (term=TerminalExpr) ("[" (exprT=Expression (Comma expr+=Expression)*)? "]"																|//8./												
  ( "+" | "&" | Dote | "-" | "||" | "or" | "&&" | "and" | "<=>" | "iff" | "++" | "<:" | ":>" | "<<" | ">>" |">>>" ) right=Expression		|//4./
  (op="!"|"not")? ( "=" | "in" | "<" | ">" | "<=" | ">=" ) right=Expression																	|//6./													
  arrowOp=ArrowOp right=Expression																											|//5./	
  ("=>"|"implies") then=Expression ("else" right=Expression)? 																				 //7./ 
)?;

TerminalExpr returns Expression:
  "let" letDecl=LetDecl (Comma letDecl=LetDecl)* blockOrBarBis=BlockOrBar						|//1./
  ("all"|"sum") decl=Decl b=BlockOrBar															|//2./
  (unop=( "!" | "#" | "~" |  "^" )|"not"|"*" |"set"|"seq") exprT=Expression						|//3./
  ("no"|"some"|"lone"|"one") (decl=Decl (Comma declSuite+=Decl)* block=BlockOrBar|t=Expression)	|//2./ AND 3./
  INT																							|//9./
  Integer																						|//10./
  "none"																						|//11./
  "iden"																						|//12./
  "univ"																						|//13./
  "Int"																							|//14./
  "seq/Int"																						|//15./
  "(" exprT=Expression ")"																		|//16./
  "@"? nameRef=[TypeName]																			|//17./
  LeftCurlyBracket (block=Block|(decl=Decl Comma)+ blockOrBar=BlockOrBar RightCurlyBracket)		; //18 AND 19./

/*
	decl ::= ["private"] ["disj"] name,+ ":" ["disj"] expr
*/
Decl:
  (Private)? ("disj")? nameExpression+=PropertyName (Comma nameExpression+=PropertyName)* Colon ("disj")? exprDecl=Expression; 
  
/*
	letDecl ::= name "=" expr
*/
LetDecl:
  nameExpression=PropertyName "=" exprLet=Expression; 
  
/*
	arrowOp ::= ["some"|"one"|"lone"|"set"]? "->" ["some"|"one"|"lone"|"set"]? //redondance in the end of the expression
*/
ArrowOp:
  ("some"|"one"|"lone"|"set")? s="->"; 
  
/*
	block ::= "{" expr* "}" //without "{"
*/
Block:
  expr+=Expression* RightCurlyBracket; 

/*
	block ::= "{" expr* "}" //with "{"
*/
BlockBis:
  LeftCurlyBracket block=Block; 

/*
	blockOrBar ::= block
	blockOrBar ::= "|" expr
*/
BlockOrBar:
  BlockBis|"|" Expression; 
  
/*
	name ::= ["this" | ID] ["/" ID]*
*/
Name:
	this="this"|name=ID|nameComplete=NameBis;

Alias:
	name=ID|nameComplete=NameBis;
	  
AssertionName :
	this="this"|name=ID|nameComplete=NameBis;

PredicateName :
	this="this"|name=ID|nameComplete=NameBis;
	
TypeName:
	this="this"|name=ID|nameComplete=NameBis;
	
PropertyName:
	this="this"|name=ID|nameComplete=NameBis;

NameBis:
  mainName=("this"|ID) ("/" suite+=ID)+; 
  
/*
	ref ::= name | "univ" | "Int" | "seq/Int"
*/
Ref:
  name=[TypeName]|"univ"|"Int"|"seq/Int";

LeftCurlyBracket:
  "{";

RightCurlyBracket:
  "}";

Private:
  "private";
  
Comma :
",";
Dote :
".";
Colon :
":";
terminal Integer:
  "-" INT;
terminal ML_COMMENT	:
	('/*'->'*/' ) | ('--'->'\n') ;

terminal ID:
  ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* ("'")*;
