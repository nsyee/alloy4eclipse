grammar fr.univartois.cril.alloyplugin.Basics with org.eclipse.xtext.common.Terminals 
hidden (WS, ML_COMMENT, SL_COMMENT)
generate basics "http://www.univartois.fr/cril/alloyplugin/Basics"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/*
	specification ::= [module] open* paragraph*
*/
Specification  :
  module=Module? open+=Open* paragraph+=Paragraph*; 

/*
	module ::= "module" name  [ "["  ["exactly"] name  ("," ["exactly"] num)*    "]" ]
*/
Module:
  module=ModuleName (left=LeftSquareBracketKeyword "exactly"? name=Name (comma=Comma "exactly"? INT)* right=RightSquareBracketKeyword)?; 
  
/*
	open ::= ["private"]  "open"  name  [ "[" ref,+ "]" ]  [ "as" name ]
*/
Open:
  Private? openName=OpenName  (left=LeftSquareBracketKeyword ref+=Ref (comma=Comma ref+=Ref)* right=RightSquareBracketKeyword)? ("as" nameAs=Name)?; 
  
/*
	paragraph ::= factDecl | assertDecl | funDecl | cmdDecl | enumDecl | sigDecl
*/
Paragraph:
  FactDecl		|
  AssertDecl	|
  FunDecl		|
  PredDecl		|
  RunDecl		|
  CheckDecl		|
  EnumDecl		|
  SigDecl	; 

/*
	factDecl ::= "fact" [name] block
*/
FactDecl returns Fact:
  factName=FactName block=Block; 

/*
	assertDecl ::= "assert" [name] block
*/
AssertDecl returns Assertion:
  assertonName=AssertionName block=Block; 
  
/*
	funDecl ::= ["private"] "fun" [ref "."] name "(" decl,* ")" ":" expr block
	funDecl ::= ["private"] "fun" [ref "."] name "[" decl,* "]" ":" expr block
	funDecl ::= ["private"] "fun" [ref "."] name                ":" expr block
*/
FunDecl returns Function:
  Private? "fun" (ref=Ref dot=Dot)? functionName=FunctionName (
  		leftS=LeftSquareBracketKeyword (decl+=Decl (comma=Comma decl+=Decl)*)? rightS=RightSquareBracketKeyword	|
  		leftP=LeftParenthesis (decl+=Decl (comma=Comma decl+=Decl)*)? rightP=RightParenthesis
  		)? colon=Colon expr=Expression block=Block; 
  
/*
	funDecl ::= ["private"] "pred" [ref "."] name "(" decl,* ")" block
	funDecl ::= ["private"] "pred" [ref "."] name "[" decl,* "]" block
	funDecl ::= ["private"] "pred" [ref "."] name                block
*/
PredDecl returns Predicate:
  Private? "pred" (ref=Ref dot=Dot)? predicateName=PredicateName (
  		leftS=LeftSquareBracketKeyword (decl+=Decl (comma=Comma decl+=Decl)*)? rightS=RightSquareBracketKeyword	|
  		leftP=LeftParenthesis (decl+=Decl (comma=Comma decl+=Decl)*)? rightP=RightParenthesis
  		)? b=Block; 
  
/*
	cmdDecl ::= [name ":"] ["run"|"check"] [name|block] scope //JUST RUN
*/
RunDecl returns RunCommand:
  (runName=Alias ":")? run="run" (name2=[PredicateName]|b=Block) scope=Scope; 
  
/*
	cmdDecl ::= [name ":"] ["run"|"check"] [name|block] scope //JUST CHECK
*/
CheckDecl returns CheckCommand:
  (checkName=Alias ":")? check="check" (name=[AssertionName]|b=Block) scope=Scope; 
  
/*
	scope ::= "for" number                   ["expect" [0|1]]
	scope ::= "for" number "but" typescope,+ ["expect" [0|1]]
	scope ::= "for"              typescope,+ ["expect" [0|1]]
	scope ::=                                ["expect" [0|1]]	
*/
Scope:
	"for" INT 														   ("expect" ("0"|"1"))?	|
	"for" INT "but" typescope+=Typescope ("," typescope+=Typescope)*   ("expect" ("0"|"1"))?	|
	"for"           typescope+=Typescope ("," typescope+=Typescope)*   ("expect" ("0"|"1"))?	|
																	   ("expect" ("0"|"1"))?	;	
  
/*
	typescope ::= ["exactly"] number [name|"int"|"seq"]
*/
Typescope:
  "exactly"? INT (n=[ReferencesName]|("int"|"seq")); //A VOIR
  
/*
	enumDecl ::= "enum" name "{" name  ("," name)*  "}"
*/
EnumDecl:
  enumName=EnumName leftC=LeftCurlyBracket propertyEnum+=EnumPropertyName (comma=Comma propertyEnum+=EnumPropertyName)* rightC=RightCurlyBracket; 
  
/*
	sigDecl ::= sigQual* "sig" name,+ [sigExt] "{" decl,* "}" [block]
*/
SigDecl returns Signature:
  SigQual? "sig" signatureName+=SignatureName (comma=Comma signatureName+=SignatureName)* (sigExt=SigExt)? leftC=LeftCurlyBracket (decl+=Decl ("," decl+=Decl)*)? rightC=RightCurlyBracket (b=Block)?; 
  
/*
	sigQual ::= "abstract" | "lone" | "one" | "some" | "private"	
*/
SigQual:
  sigq=( "abstract" | "lone" | "one" | "some" | "private" ) ("abstract"|"lone"|"one"|"some"|"private")*; 
  
/*
	sigExt ::= "extends" ref
	sigExt ::= "in" ref ["+" ref]*
*/
SigExt:
  "extends" ref=Ref|"in" ref=Ref ("+" ref2+=Ref)*;
/*
	expr ::= "let" letDecl,+ blockOrBar						1./	
       | quant decl,+    blockOrBar							2./
       | unOp expr											3./
       | expr binOp   expr									4./
       | expr arrowOp expr									5./
       | expr ["!"|"not"]? compareOp expr					6./
       | expr ["=>"|"implies"] expr "else" expr 			7./
       | expr "[" expr,* "]"								8./
       |     number											9./
       | "-" number											10./
       | "none"												11./
       | "iden"												12./
       | "univ"												13./
       | "Int"												14./
       | "seq/Int"											15./
       | "(" expr ")"										16./
       | ["@"] Name											17./
       | block												18./
       | "{" decl,+ blockOrBar "}"							19./
	
*/
Expression:
	TerminalExpression (b=BinOp expr=Expression									|//4./
						a=ArrowOp expr=Expression								|//5./
						("!"|"not")? cmp=CompareOp expr=Expression				|//6./
						("=>"|"implies") expr=Expression ("else" expr=Expression)?	|//7./
						left=LeftSquareBracketKeyword (expr=Expression ("," expr=Expression)* )? right=RightSquareBracketKeyword									 //8./						
						)*;
TerminalExpression returns Expression:
	"let" letdecl+=LetDecl ("," letdecl+=LetDecl)* blockOrBar=BlockOrBar	|//1./
	Quant decl+=Decl ("," decl+=Decl)* blockOrBar=BlockOrBar				|//2./
	unOp=UnOp expr=Expression												|//3./
	INT																		|//9./
	NEGATIVE_INTEGER															|//10./
	"none"																	|//11./
    "iden"																	|//12./
    "univ"																	|//13./
    "Int"																	|//14./
    "seq/Int"																|//15./
    "(" Expression ")"														|//16./
    "@"? nameRef=Name/*[ReferencesName]*/														|//17./
    Block																	|//18./
    "{" decl+=Decl ("," decl+=Decl)* blockOrBar=BlockOrBar "}"				;//19./

/*
	decl ::= ["private"] ["disj"] name,+ ":" ["disj"] expr
*/
Decl:
  (Private)? ("disj")? propertyName+=PropertyName (comma=Comma propertyName+=PropertyName)* colon=Colon ("disj")? exprDecl=Expression; 
  
/*
	letDecl ::= name "=" expr
*/
LetDecl:
  nameExpression=PropertyName "=" exprLet=Expression; 
  
/*
	quant ::= "all" | "no" | "some" | "lone" | "one" | "sum"
*/
Quant	:
	"all" | "no" | "some" | "lone" | "one" | "sum";

/*	
	binOp ::= "||" | "or" | "&&" | "and" | "&" | "<=>" | "iff"| "=>" | "implies" | "+" | "-" | "++" | "<:" | ":>" | "." | "<<" | ">>" | ">>>"
*/	
BinOp	: 
	"||" | "or" | "&&" | "and" | "&" | "<=>" | "iff"
        |"+" | "-" | "++" | "<:" | ":>" | op="." | "<<" | ">>" | ">>>";

/*
	unOp ::= "!" | "not" | "no" | "some" | "lone" | "one" | "set" | "seq" | "#" | "~" | "*" | "^"
*/
//ici
UnOp	:
	 "not" | "no" | "some" | "lone" | "one" | "set" | "seq" | op=("!" | "#" | "~" | "*" | "^");

/*
	compareOp ::= "=" | "in" | "<" | ">" | "=<" | ">="
*/	
CompareOp	:
	"=" | "in" | "<" | ">" | "=<" | "<=" /* UNDOCUMENTED */| ">=";
	
/*
	arrowOp ::= ["some"|"one"|"lone"|"set"]? "->" ["some"|"one"|"lone"|"set"]? 
*/
ArrowOp:
  ("some"|"one"|"lone"|"set")? s="->"; 
   
/*
	block ::= "{" expr* "}"
*/
Block:
  leftC=LeftCurlyBracket (exp+=Expression)* rightC=RightCurlyBracket; 

/*
	blockOrBar ::= block
	blockOrBar ::= "|" expr
*/
BlockOrBar:
  Block				|
  "|" Expression	; 
  
/*
	name ::= ["this" | ID] ["/" ID]*
*/

ModuleName :
	"module" name=Name;
	
OpenName	:
	"open" name=Name;
	
FactName	:
	"fact" name=Name?;

AssertionName :
	"assert" name=Name?;
	
FunctionName	:
	 name=Name;

PredicateName :
	 name=Name;
			
Alias:
	name=NameAlias;

EnumName	:
	"enum" name=Name;
	
EnumPropertyName	:
	 name=Name;
	 	
SignatureName :
	name=Name  ;
		
PropertyName:
	name=Name;

NameAlias:
	name=ID|name=NameBis;
	
Name:
	"this"|ID|NameBis;

NameBis:
 	("this"|ID) ("/" ID)+; 
  
/*
	ref ::= name | "univ" | "Int" | "seq/Int"
*/
ReferencesName	:
	FactName		|
	FunctionName	|
	EnumName		|
	EnumPropertyName|
	SignatureName	|
	//PropertyName	|
	PredicateName;
	
Ref:
  nameRef=[ReferencesName]|"univ"|"Int"|"seq/Int";//A VOIR

LeftCurlyBracket:
  leftCurlyBracket="{";

RightCurlyBracket:
  rightCurlyBracket="}";

Private:
  "private";

Dot:
	dot=".";
  
Comma :
comma=",";

Colon :
	colon=":";
LeftParenthesis:
	leftParenthesis="(";

RightParenthesis:
	rightParenthesis=")";
	
LeftSquareBracketKeyword:
	leftSquareBracketKeyword="[";

RightSquareBracketKeyword:
	rightSquareBracketKeyword="]";

terminal NEGATIVE_INTEGER:
  "-" INT;

terminal ML_COMMENT	:
	('/*'->'*/' ) | ('--'->'\n') ;

terminal ID:
  ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* ("'")*;
