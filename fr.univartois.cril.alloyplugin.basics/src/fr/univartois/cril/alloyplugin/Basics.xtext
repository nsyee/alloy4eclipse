grammar fr.univartois.cril.alloyplugin.Basics with org.eclipse.xtext.common.Terminals
hidden(WS, ML_COMMENT, SL_COMMENT,COMMENT)
generate basics "http://www.univartois.fr/cril/alloyplugin/Basics"

/*
	specification ::= [module] open* paragraph*
*/
Specification	:
	module=Module? open+=Open* paragraph+=Paragraph* ;
	
/*
	module ::= "module" name  [ "["  ["exactly"] name  ("," ["exactly"] num)*    "]" ]
*/	
Module	:
	"module" moduleName=Name ("[" "exactly"? suite=Name ("," "exactly"? INT)* "]")?;
	
/*
	open ::= ["private"]  "open"  name  [ "[" ref,+ "]" ]  [ "as" name ]
*/	
Open	:
	"private"? "open" name=Name ("[" ref=Ref ("," ref2+=Ref)* "]")? ("as" name2=Name)?;
	
/*
	paragraph ::= factDecl | assertDecl | funDecl | cmdDecl | enumDecl | sigDecl
*/
Paragraph	:
	FactDecl	|
	AssertDecl	|
	FunDecl		|
	PredDecl	|
	RunDecl		|
	CheckDecl	|
	EnumDecl	|
	SigDecl		;

/*
	factDecl ::= "fact" [name] block
*/
FactDecl returns Fact :
	"fact" factName=Name? b=BlockBis;

/*
	assertDecl ::= "assert" [name] block
*/
AssertDecl	returns Assertion :
	"assert" assertName=Name? b=BlockBis;
	
/*
	funDecl ::= ["private"] "fun" [ref "."] name "(" decl,* ")" ":" expr block
	funDecl ::= ["private"] "fun" [ref "."] name "[" decl,* "]" ":" expr block
	funDecl ::= ["private"] "fun" [ref "."] name                ":" expr block
*/	
FunDecl	returns Function :
	"private"? "fun" (ref=Ref ".")? funName=Name	( "[" (decl=Decl ("," decl2+=Decl)*)? "]" | "(" (decl=Decl ("," decl2+=Decl)*)? ")" ) ":" expr=Expression b=BlockBis	;

/*
	funDecl ::= ["private"] "pred" [ref "."] name "(" decl,* ")" block
	funDecl ::= ["private"] "pred" [ref "."] name "[" decl,* "]" block
	funDecl ::= ["private"] "pred" [ref "."] name                block
*/	
PredDecl returns Predicate	:
	"private"? pred="pred" (ref=Ref ".")? predName=Name	( "[" (decl=Decl ("," decl2+=Decl)*)? "]" | "(" (decl=Decl ("," decl2+=Decl)*)? ")" )?  b=BlockBis	;

/*
	cmdDecl ::= [name ":"] ["run"|"check"] [name|block] scope //JUST RUN
*/
RunDecl	returns RunCommand :
	(runName=Name ":")? run="run" (name2=[Name]| b=BlockBis ) scope=Scope;

/*
	cmdDecl ::= [name ":"] ["run"|"check"] [name|block] scope //JUST CHECK
*/	
CheckDecl	returns CheckCommand :
	(checkName=Name ":")? check="check" (name2=[Name]| b=BlockBis ) scope=Scope;
	
/*
	scope ::= "for" number                   ["expect" [0|1]]
	scope ::= "for" number "but" typescope,+ ["expect" [0|1]]
	scope ::= "for"              typescope,+ ["expect" [0|1]]
	scope ::=                                ["expect" [0|1]]
	
*/	
Scope	:
	("for" (INT ("but" typescope=Typescope ("," typescope=Typescope)*)?|typescope=Typescope ("," typescope=Typescope)*)? )?	("expect" ("0"|"1") )? 	;										

/*
	typescope ::= ["exactly"] number [name|"int"|"seq"]
*/
Typescope	:
	"exactly"? INT (n=[Name]|("int"|"seq"))	;
		
/*
	enumDecl ::= "enum" name "{" name  ("," name)*  "}"
*/
EnumDecl	:
	"enum" enumName=Name "{" name2=Name ("," name3+=Name)* "}";

/*
	sigDecl ::= sigQual* "sig" name,+ [sigExt] "{" decl,* "}" [block]
*/	
SigDecl	returns Signature :
	SigQual* "sig" sigName=Name ("," name2+=Name)* (sigExt=SigExt)? "{" (decl=Decl ("," decl2+=Decl)* )? "}" (b=BlockBis)?;
	
/*
	sigQual ::= "abstract" | "lone" | "one" | "some" | "private"	
*/
SigQual	:
	"abstract"		|
	"lone"			|
	"one"			|
	"some"			|
	"private"		;

/*
	sigExt ::= "extends" ref
	sigExt ::= "in" ref ["+" ref]*
*/	
SigExt	:
	"extends" ref=Ref				|  
	"in" ref=Ref ("+" ref2+=Ref)*	;

/*
	expr ::= "let" letDecl,+ blockOrBar						1./	
       | quant decl,+    blockOrBar							2./
       | unOp expr											3./
       | expr binOp   expr									4./
       | expr arrowOp expr									5./
       | expr ["!"|"not"]? compareOp expr					6./
       | expr ["=>"|"implies"] expr "else" expr //PROBLEM	7./
       | expr "[" expr,* "]"								8./
       |     number											9./
       | "-" number											10./
       | "none"												11./
       | "iden"												12./
       | "univ"												13./
       | "Int"												14./
       | "seq/Int"											15./
       | "(" expr ")"										16./
       | ["@"] Name											17./
       | block												18./
       | "{" decl,+ blockOrBar "}"							19./
	
*/	
Expression :
	
	(term=TerminalExpr) 	(
						"[" exprT=Expression* "]"											|//8./												
						op=("+"|"&"|"."|"-"|"||"|"or"|"&&"|"and"|"<=>"|"iff"/*|"=>"|"implies"*/|"++"|"<:"|":>"|"<<"	|">>"|">>>") right=Expression 	|//4./
						("!"|"not")? op=("="|"in"|"<"|">"|"<="|"=>") right=Expression		|//6./													
						arrowOp=ArrowOp right=Expression									//5./																						//|	
						//("=>"|"implies") (then=Expression ("else" right=Expression)? )    //7./   
						)?;
						
TerminalExpr returns Expression:
	"let" LetDecl ("," letDecl=LetDecl)* blockOrBarBis=BlockOrBarBis		|//1./
	("all"|"sum") decl=Decl b=BlockOrBarBis					|//2./
	("!"|"not"|"set"|"seq"|"#"|"~"|"*"|"^") TerminalExpr	|//3./
   	("no"|"some"|"lone"|"one") ( /*Decl ("," declSuite+=Decl)* block=BlockOrBarBis |*/ t=TerminalExpr)|//2./ AND 3./ ERROR with Decl here 
    INT																			|//9./
   	Integer																		|//10./
	"none"																		|//11./
	"iden"																		|//12./
	"univ"																		|//13./
	"Int"																		|//14./
	"seq/Int"																	|//15./
	"(" exprT=Expression ")"													|//16./
	"@"? nameRef=[Name]														|//17./
	"{" (Block | (decl=Decl ",")+ blockOrBar=BlockOrBar "}")					;//18 AND 19./
	
/*
	decl ::= ["private"] ["disj"] name,+ ":" ["disj"] expr
*/	
Decl	:
	("private")? ("disj")? name=Name ("," suite+=Name)*    ":" ("disj")? exprDecl=Expression	;

/*
	REMOVE
*/
Decl2	:
	("private")? ("disj")? Name ":" ("disj")? exprDecl=Expression	;
	
/*
	letDecl ::= name "=" expr
*/	
LetDecl	:
	Name "=" exprLet=Expression	;

/*
	arrowOp ::= ["some"|"one"|"lone"|"set"]? "->" ["some"|"one"|"lone"|"set"]? //redondance in the end of the expression
*/
ArrowOp	:
	("some" | "one" | "lone" | "set" )? s="->";

/*
	block ::= "{" expr* "}" //without "{"
*/
Block	:
	expr+=Expression* "}";

/*
	block ::= "{" expr* "}" //with "{"
*/
BlockBis	:
	"{" Block	;

/*
	blockOrBar ::= block
	blockOrBar ::= "|" expr
*/	
BlockOrBar	:
	BlockBis					|
	"|" Expression	;

/*
	blockOrBar ::= block
	blockOrBar ::= "|" expr //TerminalExpr in the end of the expression
*/	
BlockOrBarBis	:
	BlockBis					|
	"|" TerminalExpr	;

/*
	name ::= ["this" | ID] ["/" ID]*
*/
Name :
	this="this"		|
	name=ID			|
	nameComplete=NameBis		;

NameBis:
	("this"|ID) ("/" suite=ID)+;

/*
	ref ::= name | "univ" | "Int" | "seq/Int"
*/	
Ref	:
	name=[Name]	|
	"univ"		|
	"Int"		|
	"seq/Int"	;
	
terminal Integer	:
	"-" INT;
	
terminal COMMENT	:
	'--'->'\n';	
	
terminal ID : 
  ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*("'")*; 
	
/*
Instruction	:
	M	| U;
	
M	:
	Expression ("=>" then=M "else" else=M)?;
	
U	:
	Expression "=>" then=Instruction	|
	Expression ("=>" then=M "else" else=U;*/